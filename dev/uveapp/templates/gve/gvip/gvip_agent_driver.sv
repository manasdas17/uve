/****************************************************************************
 *	Copyright 2012 HES-SO HEIG-VD
 *	Copyright 2011 HES-SO Valais Wallis
 *	Copyright 2007-2010 Mentor Graphics Corporation
 *	Copyright 2007-2010 Cadence Design Systems, Inc.
 *	Copyright 2010 Synopsys, Inc.
 *	All Rights Reserved Worldwide
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *	Unless required by applicable law or agreed to in writing, software
 *	distributed under the License is distributed on an "AS IS" BASIS,
 *	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *	See the License for the specific language governing permissions and
 *	limitations under the License.
 ****************************************************************************
 * This file has been generated by UVE version $@uve_version@$
 * Date of generation: $@date@$
 *
 * Project : $@projectname@$
 * File : $@filename@$
 * Version : 1.0
 ****************************************************************************
 * Description :
 * A driver is an active entity that emulates logic that drives the DUV.
 ****************************************************************************/

`ifndef $@FILENAME@$
`define $@FILENAME@$

`include "uvm_macros.svh"

class $@ClassName@$ extends uvm_driver# ($@vip_transfer@$);

    // Virtual Interface
    protected virtual $@vip_interface@$ vif;


    // Port to monitor (not so nifty)
    uvm_blocking_put_port #($@vip_transfer@$) mon_item_port;
    bit send_to_monitor = 0;

    $@agent_class_name@$_config cfg;

    // Provide implementations of virtual methods such as get_type_name and create
    `uvm_component_utils($@ClassName@$)

    // Constructor
    function new(string name = "agent driver", uvm_component parent);
        super.new(name, parent);
    endfunction : new

    // Build phase
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);

        // Try to get a configuration object
        if (!uvm_config_db#($@agent_class_name@$_config)::get(this, "", "config", cfg))
            `uvm_fatal("GETCONFIGFAIL", "Failed to get the driver configuration")

        send_to_monitor = cfg.driver_to_monitor;


        // Create port to the monitor
        if (send_to_monitor == 1)
            mon_item_port = new("mon_item_port", this);

        // Interface
        if(!uvm_config_db#(virtual $@vip_interface@$)::get(this,"","$@vip_interface@$",vif))
            `uvm_fatal("NOVIF",{"virtual interface must be set for: ",get_full_name(),".vif"});

    endfunction : build_phase

    // Run phase
    virtual task run_phase(uvm_phase phase);
        fork
            get_and_drive();
            reset_signals();
        join
    endtask : run_phase

    // Reset signals
    virtual protected task reset_signals();
        $@ driver_resets
    endtask : reset_signals

    // Get and drive item
    virtual protected task get_and_drive();

        // Wait end of reset
/*---------------------------------------------------------------------------
 * @TODO : wait reset : @(negedge vif.reset); or @(posedge vif.reset);
 *--------------------------------------------------------------------------*/

        // Get and drive
        forever begin
            seq_item_port.get_next_item(req);    // Get the next data item from sequencer
            if (send_to_monitor == 1)
                mon_item_port.put(req);

            $cast(rsp, req.clone());             // Copy request in response
            rsp.set_id_info(req);                // Set id
            drive_transfer(rsp);                 // Write request on the bus / get response
            seq_item_port.item_done();           // Indicate that item is done
            //     seq_item_port.put_response(rsp);   // Send response
        end
    endtask : get_and_drive

    // Drive transfer
    virtual protected task drive_transfer($@vip_transfer@$ trans);

/*---------------------------------------------------------------------------
 * @TODO : drive transfer to interface
 *--------------------------------------------------------------------------*/
            
           $@ driver_drive
           
    endtask : drive_transfer

endclass : $@ClassName@$

`endif /* $@FILENAME@$ */
