/****************************************************************************
 *	Copyright 2012 HES-SO HEIG-VD
 *	Copyright 2011 HES-SO Valais Wallis
 *	Copyright 2007-2010 Mentor Graphics Corporation
 *	Copyright 2007-2010 Cadence Design Systems, Inc.
 *	Copyright 2010 Synopsys, Inc.
 *	All Rights Reserved Worldwide
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *	Unless required by applicable law or agreed to in writing, software
 *	distributed under the License is distributed on an "AS IS" BASIS,
 *	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *	See the License for the specific language governing permissions and
 *	limitations under the License.
 ****************************************************************************
 * This file has been generated by UVE version $@uve_version@$
 * Date of generation: $@date@$
 *
 * Project : $@projectname@$
 * File : $@filename@$
 * Version : 1.0
 ****************************************************************************
 * Description :
 * This class defines the test scenario for the testbench specified in the
 * test.
 ****************************************************************************/

`ifndef $@FILENAME@$
`define $@FILENAME@$

`include "uvm_macros.svh"
`include "$@gtb_tb_filename@$"

/**********************************************************
 * Base test
 **********************************************************/

class $@ClassName@$ extends uvm_test;

    // Provide implementations of virtual methods such as get_type_name and create
    `uvm_component_utils($@ClassName@$)

    // The testbench
    $@gtb_tb_class@$ $@gtb_tb_inst@$;

    // Table printer
    uvm_table_printer printer;

    // Indicate if the test is succeed
    bit test_pass = 1;

    // Constructor
    function new(string name = "$@ClassName@$", uvm_component parent=null);
        super.new(name,parent);
    endfunction : new

    // Build
    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);

        // Enable transaction recording for everything
        set_config_int("*", "recording_detail", UVM_FULL);

        // Create the testbench
        $@gtb_tb_inst@$ = $@gtb_tb_class@$::type_id::create("$@gtb_tb_inst@$", this);

        // Create a specific depth printer for printing the created topology
        printer = new();
        printer.knobs.depth = 4;

        $@ def_sequences

    endfunction : build_phase

    // End of elaboration
    function void end_of_elaboration_phase(uvm_phase phase);

        // Set verbosity for the bus monitor
        $@ bus_monitor_verbosity

        `uvm_info(get_type_name(),
                  $psprintf("Printing the test topology :\n%s",
                  this.sprint(printer)), UVM_LOW)

    endfunction : end_of_elaboration_phase

    // Run
    task run_phase(uvm_phase phase);
        //set a drain-time for the environment if desired
        phase.phase_done.set_drain_time(this, 50);
    endtask : run_phase

    // Extract
    function void extract_phase(uvm_phase phase);

       // Get scoreboard error
       //     if($@gtb_tb_inst@$.scoreboard0.sbd_error)
       //         test_pass = 1'b0;

    endfunction // void

    // Report
    function void report_phase(uvm_phase phase);
        if(test_pass) begin
            `uvm_info(get_type_name(), "** UVM TEST PASSED **", UVM_NONE)
        end
        else begin
            `uvm_error(get_type_name(), "** UVM TEST FAIL **")
        end
    endfunction

endclass : $@ClassName@$

/**********************************************************
 * user test
 **********************************************************/

/*---------------------------------------------------------------------------
 * @TODO : Create scenario
 *---- Example -------------------------------------------------------------*/

class $@ClassName@$_a_test extends $@ClassName@$;

    // Provide implementations of virtual methods such as get_type_name and create
    `uvm_component_utils($@ClassName@$_a_test)

    // Constructor
    function new(string name = "$@ClassName@$_a_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction : new

    // Build
    virtual function void build_phase(uvm_phase phase);
    begin
/*
        define the use of new sequences
        // Set master default sequence
        uvm_config_db#(uvm_object_wrapper)::set(this,
                "MyTb.MyVip.masters[0].sequencer.run_phase",
                "default_sequence",
                a_master_seq::type_id::get());
*/
        // Create the tb
        super.build_phase(phase);

    end
    endfunction : build_phase

endclass : $@ClassName@$_a_test

/*--------------------------------------------------------------------------*/

`endif /* $@FILENAME@$ */
